{
  "schema": "barkday.ai-pack-everything.v1",
  "repo": "CandidQuality/candidquality.github.io",
  "commit": "916f37bba42cae38c5e3ee433d54a67d35e9dfd2",
  "updated_utc": "2025-11-11T03:20:41.191Z",
  "count": 7,
  "items": [
    {
      "path": ".github/workflows/build_ai_index.yml",
      "size": 1311,
      "sha": "0fd4fa27b3a4427c12c009e50770451b2fd96d78",
      "media_type": "text/yaml",
      "raw_url": "https://raw.githubusercontent.com/CandidQuality/candidquality.github.io/916f37bba42cae38c5e3ee433d54a67d35e9dfd2/.github/workflows/build_ai_index.yml",
      "html_url": "https://github.com/CandidQuality/candidquality.github.io/blob/916f37bba42cae38c5e3ee433d54a67d35e9dfd2/.github/workflows/build_ai_index.yml",
      "inline_state": "full",
      "max_inline_text_bytes": 614400,
      "max_inline_bin_bytes": 204800,
      "preview_text_bytes": 65536,
      "encoding": "utf8",
      "content": "name: Build AI Index and Packs\n\non:\n  workflow_dispatch:\n  push:\n    branches: [ main ]\n    # Avoid loops when the workflow commits docs/*\n    paths-ignore:\n      - \"docs/**\"\n\npermissions:\n  contents: write\n\nconcurrency:\n  group: ai-index-${{ github.ref }}\n  cancel-in-progress: false\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n\n      - name: Use Node\n        uses: actions/setup-node@v4\n        with:\n          node-version: \"20\"\n\n      # If your repo has no npm dependencies, we skip install.\n\n      - name: Build indices and packs\n        run: node scripts/build_ai_index.mjs\n\n      - name: Commit docs if changed\n        run: |\n          if [[ -n \"$(git status --porcelain docs)\" ]]; then\n            git config user.name \"github-actions[bot]\"\n            git config user.email \"41898282+github-actions[bot]@users.noreply.github.com\"\n            git add docs\n            git commit -m \"build(ai): regenerate ai-index and packs\"\n            git push\n          else\n            echo \"No changes in docs/\"\n          fi\n        # Prevent recursion if a bot push re-triggers the job due to other filters\n        if: ${{ github.actor != 'github-actions[bot]' || github.event_name == 'workflow_dispatch' }}\n",
      "inline_bytes": 1311,
      "content_sha256": "7bc34b0cf8ed0e91e807a3d0b8a3d79a947be6fb7f2a6fac2197ba046dd8de7b"
    },
    {
      "path": ".nojekyll",
      "size": 1,
      "sha": "8b137891791fe96927ad78e64b0aad7bded08bdc",
      "media_type": "application/octet-stream",
      "raw_url": "https://raw.githubusercontent.com/CandidQuality/candidquality.github.io/916f37bba42cae38c5e3ee433d54a67d35e9dfd2/.nojekyll",
      "html_url": "https://github.com/CandidQuality/candidquality.github.io/blob/916f37bba42cae38c5e3ee433d54a67d35e9dfd2/.nojekyll",
      "inline_state": "full",
      "max_inline_text_bytes": 614400,
      "max_inline_bin_bytes": 204800,
      "preview_text_bytes": 65536,
      "encoding": "base64",
      "content": "Cg==",
      "inline_bytes": 4,
      "content_sha256": "01ba4719c80b6fe911b091a7c05124b64eeece964e09c058ef8f9805daca546b"
    },
    {
      "path": ".well-known/assetlinks.json",
      "size": 333,
      "sha": "4713b816e9575a9530d43e6be87e3985803c328b",
      "media_type": "application/json",
      "raw_url": "https://raw.githubusercontent.com/CandidQuality/candidquality.github.io/916f37bba42cae38c5e3ee433d54a67d35e9dfd2/.well-known/assetlinks.json",
      "html_url": "https://github.com/CandidQuality/candidquality.github.io/blob/916f37bba42cae38c5e3ee433d54a67d35e9dfd2/.well-known/assetlinks.json",
      "inline_state": "full",
      "max_inline_text_bytes": 614400,
      "max_inline_bin_bytes": 204800,
      "preview_text_bytes": 65536,
      "encoding": "utf8",
      "content": "[\n  {\n    \"relation\": [\"delegate_permission/common.handle_all_urls\"],\n    \"target\": {\n      \"namespace\": \"android_app\",\n      \"package_name\": \"com.candidquality.barkday\",\n      \"sha256_cert_fingerprints\": [\n        \"75:E9:A2:7F:67:1C:72:5A:2D:EC:D6:32:49:1B:1B:2E:62:48:DE:A1:D2:93:C0:5C:3F:62:60:0A:15:BB:BD:0A\"\n      ]\n    }\n  }\n]\n",
      "inline_bytes": 333,
      "content_sha256": "ac01abd5b673de77ec0a8d63b40e4a2e6e9c10b1306bc42caf0db909e53e88b4"
    },
    {
      "path": "README.md",
      "size": 28,
      "sha": "183585f0e4c0648e8330d5d5f0fb9bf2f2c13c6f",
      "media_type": "text/markdown",
      "raw_url": "https://raw.githubusercontent.com/CandidQuality/candidquality.github.io/916f37bba42cae38c5e3ee433d54a67d35e9dfd2/README.md",
      "html_url": "https://github.com/CandidQuality/candidquality.github.io/blob/916f37bba42cae38c5e3ee433d54a67d35e9dfd2/README.md",
      "inline_state": "full",
      "max_inline_text_bytes": 614400,
      "max_inline_bin_bytes": 204800,
      "preview_text_bytes": 65536,
      "encoding": "utf8",
      "content": "# github.io\nHost assetlinks\n",
      "inline_bytes": 28,
      "content_sha256": "a27de106de8d90cb96a8f2839486b5db1238870bab40205cae01763b8f01a641"
    },
    {
      "path": "index.html",
      "size": 787,
      "sha": "f2bf7099b53ac6e76c84ccf1aac1518a04354c80",
      "media_type": "text/html",
      "raw_url": "https://raw.githubusercontent.com/CandidQuality/candidquality.github.io/916f37bba42cae38c5e3ee433d54a67d35e9dfd2/index.html",
      "html_url": "https://github.com/CandidQuality/candidquality.github.io/blob/916f37bba42cae38c5e3ee433d54a67d35e9dfd2/index.html",
      "inline_state": "full",
      "max_inline_text_bytes": 614400,
      "max_inline_bin_bytes": 204800,
      "preview_text_bytes": 65536,
      "encoding": "utf8",
      "content": "<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Barkday – Redirecting…</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <link rel=\"manifest\" href=\"/manifest.json\" />\n  <meta http-equiv=\"refresh\" content=\"0; url=/Barkday/\">\n  <style>\n    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;\n         margin:0;display:grid;place-items:center;height:100dvh;background:#0b0c0e;color:#f3f4f6}\n    .card{padding:2rem 2.5rem;border:1px solid #1f2937;border-radius:14px;background:#111827}\n    a{color:#93c5fd}\n  </style>\n</head>\n<body>\n  <div class=\"card\">\n    <h1>Taking you to Barkday…</h1>\n    <p>If you’re not redirected, <a href=\"/Barkday/\">click here</a>.</p>\n  </div>\n</body>\n</html>\n\n",
      "inline_bytes": 779,
      "content_sha256": "753ec2bd36c05477a55e5f89709359e385473d18fdc1d47b1280e5d1487db40b"
    },
    {
      "path": "manifest.json",
      "size": 547,
      "sha": "a4eb8ca8bdaacf7672ac38f3fecec2765ef3e20e",
      "media_type": "application/json",
      "raw_url": "https://raw.githubusercontent.com/CandidQuality/candidquality.github.io/916f37bba42cae38c5e3ee433d54a67d35e9dfd2/manifest.json",
      "html_url": "https://github.com/CandidQuality/candidquality.github.io/blob/916f37bba42cae38c5e3ee433d54a67d35e9dfd2/manifest.json",
      "inline_state": "full",
      "max_inline_text_bytes": 614400,
      "max_inline_bin_bytes": 204800,
      "preview_text_bytes": 65536,
      "encoding": "utf8",
      "content": "{\n  \"name\": \"Barkday\",\n  \"short_name\": \"Barkday\",\n  \"description\": \"Dog birthday tracker and celebration app\",\n  \"start_url\": \"/\",\n  \"scope\": \"/\",\n  \"display\": \"standalone\",\n  \"background_color\": \"#ffffff\",\n  \"theme_color\": \"#4CAF50\",\n  \"icons\": [\n    {\n      \"src\": \"/favicon.ico\",\n      \"sizes\": \"48x48\",\n      \"type\": \"image/x-icon\"\n    },\n    {\n      \"src\": \"/barkday-logo.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\"\n    },\n    {\n      \"src\": \"/barkday-logo2.png\",\n      \"sizes\": \"512x512\",\n      \"type\": \"image/png\"\n    }\n  ]\n}\n",
      "inline_bytes": 547,
      "content_sha256": "5dd239ab45b5e6db9f2ec6f961ccb2d150c3c1b486dcda29eddf2202058f5846"
    },
    {
      "path": "scripts/build_ai_index.mjs",
      "size": 20302,
      "sha": "4ab1ba8d498344fb8d6730c2549a02272e7ef241",
      "media_type": "application/javascript",
      "raw_url": "https://raw.githubusercontent.com/CandidQuality/candidquality.github.io/916f37bba42cae38c5e3ee433d54a67d35e9dfd2/scripts/build_ai_index.mjs",
      "html_url": "https://github.com/CandidQuality/candidquality.github.io/blob/916f37bba42cae38c5e3ee433d54a67d35e9dfd2/scripts/build_ai_index.mjs",
      "inline_state": "full",
      "max_inline_text_bytes": 614400,
      "max_inline_bin_bytes": 204800,
      "preview_text_bytes": 65536,
      "encoding": "utf8",
      "content": "// scripts/build_ai_index.mjs\n// Builds repo-wide indices (ai-index.*), browsable lists, targeted inline packs,\n// sharded \"everything\" packs, and a combined \"all\" pack with HTML/TXT mirrors.\n// Safer defaults for large data, plus JSON shape hints for very large files.\n\nimport { execSync } from \"node:child_process\";\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport crypto from \"node:crypto\";\n\n// ---------------- git + repo meta ----------------\nfunction safeExec(cmd, def = \"\") {\n  try { return execSync(cmd, { encoding: \"utf8\", stdio: [\"ignore\",\"pipe\",\"ignore\"] }).trim(); }\n  catch { return def; }\n}\n\nconst repo = process.env.GITHUB_REPOSITORY\n  || safeExec(\"git config --get remote.origin.url\")\n      .replace(/^.*github\\.com[:/]/, \"\").replace(/\\.git$/, \"\");\nconst commit = process.env.GITHUB_SHA || safeExec(\"git rev-parse HEAD\");\nconst branch = process.env.GITHUB_REF_NAME || safeExec(\"git rev-parse --abbrev-ref HEAD\") || \"main\";\nconst updatedUtc = new Date().toISOString();\n\nif (!repo) {\n  console.warn(\"[build_ai_index] Could not determine repo; continuing with minimal metadata.\");\n}\n\n// ---------------- helpers ----------------\nfunction enc(p){ return p.split(\"/\").map(encodeURIComponent).join(\"/\"); }\nfunction mediaTypeFor(p){\n  const ext = p.toLowerCase().split(\".\").pop();\n  const map = {\n    json:\"application/json\", schema:\"application/json\",\n    js:\"application/javascript\", mjs:\"application/javascript\",\n    css:\"text/css\", html:\"text/html\", md:\"text/markdown\", mdx:\"text/markdown\", txt:\"text/plain\",\n    svg:\"image/svg+xml\", png:\"image/png\", jpg:\"image/jpeg\", jpeg:\"image/jpeg\", webp:\"image/webp\", ico:\"image/x-icon\",\n    pdf:\"application/pdf\", xml:\"application/xml\", yml:\"text/yaml\", yaml:\"text/yaml\"\n  };\n  return map[ext] || \"application/octet-stream\";\n}\nfunction sha256(buf){ return crypto.createHash(\"sha256\").update(buf).digest(\"hex\"); }\nfunction ensureDocs(){ fs.mkdirSync(\"docs\", { recursive: true }); }\n\n// ---------------- gather all tracked files at this commit ----------------\nfunction filesFromGitTree(gitCommit) {\n  const raw = safeExec(`git ls-tree -r --long ${gitCommit}`);\n  const lines = raw.split(\"\\n\").filter(Boolean);\n  const out = [];\n  for (const line of lines) {\n    const m = line.match(/^\\d+\\s+\\w+\\s+([0-9a-f]{40})\\s+(\\d+)\\t(.+)$/);\n    if (!m) continue;\n    const [, blobSha, sizeStr, filePath] = m;\n    if (filePath.startsWith(\".git/\")) continue;\n    const raw_url  = `https://raw.githubusercontent.com/${repo}/${commit}/${enc(filePath)}`;\n    const html_url = `https://github.com/${repo}/blob/${commit}/${enc(filePath)}`;\n    out.push({ path:filePath, size:Number(sizeStr), git_blob_sha:blobSha, media_type:mediaTypeFor(filePath), raw_url, html_url });\n  }\n  return out;\n}\n// Fallback (rare): walk working dir if git tree fails\nfunction walk(dir){\n  const ents = fs.readdirSync(dir, { withFileTypes:true });\n  const list = [];\n  for (const e of ents){\n    const p = path.join(dir, e.name);\n    if (p.startsWith(\".git\")) continue;\n    if (e.isDirectory()) list.push(...walk(p));\n    else {\n      const stat = fs.statSync(p);\n      list.push({\n        path: p.replace(/^[.][/\\\\]*/,\"\"),\n        size: stat.size,\n        git_blob_sha: \"\", // unknown outside git\n        media_type: mediaTypeFor(p),\n        raw_url: `https://raw.githubusercontent.com/${repo}/${commit}/${enc(p)}`,\n        html_url:`https://github.com/${repo}/blob/${commit}/${enc(p)}`\n      });\n    }\n  }\n  return list;\n}\n\nlet files = filesFromGitTree(commit);\nif (!files.length) {\n  console.warn(\"[build_ai_index] git ls-tree returned no files; falling back to FS walk.\");\n  files = walk(\".\");\n}\n\n// ---------------- master index ----------------\nensureDocs();\nconst index = {\n  schema: \"barkday.ai-index.v1\",\n  repo, default_branch: branch, commit, updated_utc: updatedUtc,\n  files_count: files.length,\n  total_bytes: files.reduce((a,f)=>a+f.size, 0),\n  files\n};\nfs.writeFileSync(\"docs/ai-index.json\", JSON.stringify(index, null, 2));\nfs.writeFileSync(\"docs/ai-index.min.json\", JSON.stringify(index));\nconsole.log(`Wrote docs/ai-index.(json|min.json) with ${files.length} entries`);\n\n// ---------------- simple list writer (json + min.json + html) ----------------\nfunction writeList({title, outBase, predicate}) {\n  const subset = files.filter(predicate);\n  const list = {\n    schema: `barkday.${outBase}.v1`,\n    repo, commit, updated_utc: updatedUtc,\n    count: subset.length,\n    files: subset.map(({path: p, size, git_blob_sha, raw_url, html_url}) => ({\n      path: p, size, sha: git_blob_sha, raw_url, html_url\n    }))\n  };\n  fs.writeFileSync(`docs/${outBase}.json`, JSON.stringify(list, null, 2));\n  fs.writeFileSync(`docs/${outBase}.min.json`, JSON.stringify(list));\n\n  const esc = s => String(s).replace(/&/g,\"&amp;\").replace(/</g,\"&lt;\").replace(/>/g,\"&gt;\");\n  const rows = subset.map(f =>\n    `<tr><td class=\"mono\">${esc(f.path)}</td><td>${f.size}</td><td><a href=\"${f.raw_url}\" target=\"_blank\" rel=\"noopener\">raw</a></td><td><a href=\"${f.html_url}\" target=\"_blank\" rel=\"noopener\">view</a></td></tr>`\n  ).join(\"\\n\") || `<tr><td colspan=\"4\">No matching files.</td></tr>`;\n\n  const html = `<!doctype html><meta charset=\"utf-8\"><title>Barkday • ${esc(title)}</title>\n<style>\n  body{font:14px system-ui;margin:24px;max-width:1100px}\n  table{width:100%;border-collapse:collapse}\n  th,td{border-bottom:1px solid #eee;padding:8px;text-align:left}\n  .mono{font-family:ui-monospace,Consolas,monospace}\n</style>\n<h1>${esc(title)} (${subset.length})</h1>\n<p><small>Commit <code>${commit.slice(0,7)}</code> • ${updatedUtc}</small></p>\n<table><thead><tr><th>Path</th><th>Size</th><th>Raw</th><th>HTML</th></tr></thead><tbody>\n${rows}\n</tbody></table>`;\n  fs.writeFileSync(`docs/${outBase}.html`, html);\n\n  console.log(`Wrote docs/${outBase}.(html|json|min.json) with ${subset.length} entries`);\n}\n\nwriteList({\n  title: \"docs/*.md Markdown files\",\n  outBase: \"ai-docs-list\",\n  predicate: f => f.path.startsWith(\"docs/\") && /\\.mdx?$/i.test(f.path)\n});\nwriteList({\n  title: \"data/*.md Markdown files\",\n  outBase: \"ai-data-list\",\n  predicate: f => f.path.startsWith(\"data/\") && /\\.mdx?$/i.test(f.path)\n});\nwriteList({\n  title: \"data/*.json, *.yaml, *.yml files\",\n  outBase: \"ai-data-config-list\",\n  predicate: f => f.path.toLowerCase().startsWith(\"data/\") && /\\.(json|ya?ml)$/i.test(f.path)\n});\n\n// ---------------- inline limits + policy ----------------\nconst TEXT_EXT = new Set([\"md\",\"mdx\",\"json\",\"js\",\"mjs\",\"css\",\"html\",\"yml\",\"yaml\",\"txt\",\"svg\"]);\nconst INLINE_TEXT_BYTES  = 600 * 1024;   // inline full text <= 600 KB\nconst INLINE_BIN_BYTES   = 200 * 1024;   // inline full binary <= 200 KB (base64)\nconst PREVIEW_TEXT_BYTES = 64  * 1024;   // if too large for full, include this much preview\n\n// Always inline full for docs/*.md, but NOT every data file by default (keeps packs lean).\nconst ALWAYS_TEXT_FULL_DIRS = [ /^docs\\//i ];\nconst ALWAYS_TEXT_FULL_PATHS = new Set([\n  // explicitly required data/config for automation\n  \"dog-gifts.json\",\n  \"dog-gifts.schema.json\"\n]);\nfunction alwaysFullText(p){\n  if (ALWAYS_TEXT_FULL_PATHS.has(p)) return true;\n  return ALWAYS_TEXT_FULL_DIRS.some(rx => rx.test(p));\n}\n\n// low-level git blob read\nfunction execSyncBuffer(cmd){ return execSync(cmd, { encoding: \"buffer\", stdio: [\"ignore\",\"pipe\",\"inherit\"]}); }\nfunction gitShow(p){\n  try { return execSyncBuffer(`git show ${commit}:${p}`); }\n  catch { return fs.readFileSync(p); }\n}\n\n// ---------------- optional JSON shape hints for large files ----------------\nfunction jsonShapeHint(buf){\n  try {\n    const text = buf.toString(\"utf8\");\n    const data = JSON.parse(text);\n    const hint = { type: Array.isArray(data) ? \"array\" : (data && typeof data === \"object\" ? \"object\" : typeof data) };\n    if (Array.isArray(data)) {\n      hint.length = data.length;\n      hint.sample = data.slice(0, Math.min(3, data.length));\n    } else if (data && typeof data === \"object\") {\n      hint.keys = Object.keys(data).slice(0, 12);\n    }\n    return hint;\n  } catch {\n    return undefined;\n  }\n}\n\n// ---------------- generic inline pack writer ----------------\nconst PACK_CATALOG = []; // collect emitted packs for a small catalog at the end\n\nfunction writePack({title, outBase, predicate}){\n  const subset = files.filter(predicate);\n  const items = [];\n  for (const f of subset){\n    const ext = (f.path.split(\".\").pop()||\"\").toLowerCase();\n    const isText = TEXT_EXT.has(ext);\n    const mustFull = isText && alwaysFullText(f.path);\n\n    let inline_state = \"none\";   // \"full\" | \"preview\" | \"none\"\n    let encoding, content, content_sha, meta;\n\n    try {\n      const buf = gitShow(f.path);\n      if (isText) {\n        if (mustFull || f.size <= INLINE_TEXT_BYTES) {\n          inline_state = \"full\"; encoding = \"utf8\"; content = buf.toString(\"utf8\");\n          content_sha = sha256(buf);\n        } else if (PREVIEW_TEXT_BYTES > 0) {\n          inline_state = \"preview\"; encoding = \"utf8\"; content = buf.slice(0, PREVIEW_TEXT_BYTES).toString(\"utf8\");\n          content_sha = sha256(buf); // hash of full file (even if preview)\n          if (ext === \"json\") meta = { json_hint: jsonShapeHint(buf) };\n        }\n      } else if (f.size <= INLINE_BIN_BYTES) {\n        inline_state = \"full\"; encoding = \"base64\"; content = buf.toString(\"base64\");\n        content_sha = sha256(buf);\n      }\n    } catch { /* metadata only */ }\n\n    const item = {\n      path: f.path,\n      size: f.size,\n      sha: f.git_blob_sha,\n      media_type: f.media_type,\n      raw_url: f.raw_url,\n      html_url: f.html_url,\n      inline_state,\n      max_inline_text_bytes: INLINE_TEXT_BYTES,\n      max_inline_bin_bytes:  INLINE_BIN_BYTES,\n      preview_text_bytes:    PREVIEW_TEXT_BYTES\n    };\n    if (inline_state !== \"none\"){\n      item.encoding = encoding;\n      item.content  = content;\n      item.inline_bytes = typeof content === \"string\" ? content.length : 0;\n      item.content_sha256 = content_sha;\n      if (meta) Object.assign(item, meta);\n    }\n    items.push(item);\n  }\n\n  const pack = { schema: `barkday.${outBase}.v1`, repo, commit, updated_utc: updatedUtc, count: items.length, items };\n  const pretty = JSON.stringify(pack, null, 2);\n  const min    = JSON.stringify(pack);\n\n  fs.writeFileSync(`docs/${outBase}.json`, pretty);\n  fs.writeFileSync(`docs/${outBase}.min.json`, min);\n  fs.writeFileSync(`docs/${outBase}.txt`, min); // TXT mirror for JSON-hostile clients\n  console.log(`Wrote docs/${outBase}.(json|min.json|txt) with ${items.length} items`);\n\n  PACK_CATALOG.push({ name: outBase, count: items.length, bytes_min: min.length, files: [\n    `docs/${outBase}.json`, `docs/${outBase}.min.json`, `docs/${outBase}.txt`\n  ]});\n}\n\n// ---------------- targeted packs ----------------\nconst CORE_SET = new Set([\n  \"index.html\",\n  \"app.js\",\n  \"app-pdf.js\",\n  \"app-curves-inline.js\",\n  \"app-celebrate.js\",\n  \"service-worker.js\",\n  \"js/runtime-fetch.js\",\n  \"dog-gifts.json\",\n  \"dog-gifts.schema.json\",\n  // added for UI/Core access in packs\n  \"style.css\",\n  \"manifest.json\"\n]);\n\nwritePack({\n  title: \"docs/*.md (inline)\",\n  outBase: \"ai-pack-docs\",\n  predicate: f => f.path.startsWith(\"docs/\") && /\\.mdx?$/i.test(f.path)\n});\nwritePack({\n  title: \"data/*.json|*.yaml (inline selectively)\",\n  outBase: \"ai-pack-data-config\",\n  predicate: f => f.path.toLowerCase().startsWith(\"data/\") && /\\.(json|ya?ml)$/i.test(f.path)\n});\nwritePack({\n  title: \"core app/source files (inline)\",\n  outBase: \"ai-pack-core\",\n  predicate: f => CORE_SET.has(f.path)\n});\nwritePack({\n  title: \".github/workflows/*.yml (inline)\",\n  outBase: \"ai-pack-ci\",\n  predicate: f => f.path.startsWith(\".github/workflows/\") && /\\.ya?ml$/i.test(f.path)\n});\n\n// ---------------- SHARDED \"EVERYTHING\" PACK ----------------\nconst SHARD_TARGET_BYTES = 4 * 1024 * 1024;  // ~4 MB minified JSON per shard\nconst SHARD_MAX_ITEMS    = 500;\n\nfunction isTextPath(p){\n  const ext = (p.split('.').pop()||'').toLowerCase();\n  return TEXT_EXT.has(ext) || /^text\\//.test(mediaTypeFor(p));\n}\n\nfunction writeEverythingSharded(){\n  // exclude generated outputs and git internals\n  const subset = files.filter(f =>\n    !f.path.startsWith('docs/ai-') &&\n    !f.path.startsWith('.git/')\n  );\n\n  let items = [], bytes = 0, shardIdx = 1;\n  const shards = [];\n\n  function flush(){\n    if (!items.length) return;\n    const name = `ai-pack-everything-${String(shardIdx).padStart(4,'0')}`;\n    const pack = {\n      schema: \"barkday.ai-pack-everything.v1\",\n      repo, commit, updated_utc: updatedUtc,\n      count: items.length,\n      items\n    };\n    const pretty = JSON.stringify(pack, null, 2);\n    const min    = JSON.stringify(pack);\n    fs.writeFileSync(`docs/${name}.json`, pretty);\n    fs.writeFileSync(`docs/${name}.min.json`, min);\n    fs.writeFileSync(`docs/${name}.txt`,  min);\n    shards.push({ name, count: items.length, approx_bytes: min.length });\n    shardIdx++; items = []; bytes = 0;\n    console.log(`Wrote docs/${name}.(json|min.json|txt)  items=${pack.count}`);\n  }\n\n  for (const f of subset){\n    let inline_state = \"none\", encoding, content, content_sha, meta;\n\n    try {\n      const buf = gitShow(f.path);\n      if (isTextPath(f.path)) {\n        if (alwaysFullText(f.path) || f.size <= INLINE_TEXT_BYTES) {\n          inline_state = \"full\"; encoding = \"utf8\"; content = buf.toString(\"utf8\");\n          content_sha = sha256(buf); bytes += content.length;\n        } else if (PREVIEW_TEXT_BYTES > 0) {\n          inline_state = \"preview\"; encoding = \"utf8\"; content = buf.slice(0, PREVIEW_TEXT_BYTES).toString(\"utf8\");\n          content_sha = sha256(buf); bytes += content.length;\n          if (/\\.(json)$/i.test(f.path)) meta = { json_hint: jsonShapeHint(buf) };\n        }\n      } else if (f.size <= INLINE_BIN_BYTES) {\n        inline_state = \"full\"; encoding = \"base64\"; content = buf.toString(\"base64\");\n        content_sha = sha256(buf); bytes += content.length;\n      }\n    } catch { /* metadata only */ }\n\n    const item = {\n      path: f.path,\n      size: f.size,\n      sha:  f.git_blob_sha,\n      media_type: f.media_type,\n      raw_url:  f.raw_url,\n      html_url: f.html_url,\n      inline_state,\n      max_inline_text_bytes: INLINE_TEXT_BYTES,\n      max_inline_bin_bytes:  INLINE_BIN_BYTES,\n      preview_text_bytes:    PREVIEW_TEXT_BYTES\n    };\n    if (inline_state !== \"none\"){\n      item.encoding = encoding;\n      item.content  = content;\n      item.inline_bytes = typeof content === \"string\" ? content.length : 0;\n      item.content_sha256 = content_sha;\n      if (meta) Object.assign(item, meta);\n    }\n\n    items.push(item);\n    if (bytes >= SHARD_TARGET_BYTES || items.length >= SHARD_MAX_ITEMS) flush();\n  }\n  flush();\n\n  // Manifest + HTML index\n  const manifest = {\n    schema: \"barkday.ai-pack-everything.manifest.v1\",\n    repo, commit, updated_utc: updatedUtc,\n    shards: shards.map(s => ({\n      name: s.name,\n      count: s.count,\n      approx_bytes: s.approx_bytes,\n      url_json: `docs/${s.name}.min.json`,\n      url_txt:  `docs/${s.name}.txt`\n    }))\n  };\n  fs.writeFileSync(\"docs/ai-pack-everything.manifest.json\",     JSON.stringify(manifest, null, 2));\n  fs.writeFileSync(\"docs/ai-pack-everything.manifest.min.json\", JSON.stringify(manifest));\n\n  const rows = shards.map(s =>\n    `<tr><td><code>${s.name}</code></td><td>${s.count}</td><td>${s.approx_bytes}</td><td><a href=\"${s.name}.txt\" target=\"_blank\">txt</a> · <a href=\"${s.name}.min.json\" target=\"_blank\">json</a></td></tr>`\n  ).join(\"\\n\") || `<tr><td colspan=\"4\">No shards emitted.</td></tr>`;\n\n  const html = `<!doctype html><meta charset=\"utf-8\">\n  <title>Barkday • ai-pack-everything</title>\n  <style>body{font:14px system-ui;margin:24px;max-width:1100px} table{width:100%;border-collapse:collapse} th,td{border-bottom:1px solid #eee;padding:8px;text-align:left} code{font-family:ui-monospace,Consolas,monospace}</style>\n  <h1>ai-pack-everything</h1>\n  <p><small>Commit <code>${commit.slice(0,7)}</code> • ${updatedUtc}</small></p>\n  <table><thead><tr><th>Shard</th><th>Items</th><th>~Bytes</th><th>Links</th></tr></thead><tbody>\n  ${rows}\n  </tbody></table>`;\n  fs.writeFileSync(\"docs/ai-pack-everything.html\", html);\n\n  console.log(`Wrote docs/ai-pack-everything.(manifest.json|min.json|html) with ${shards.length} shard(s)`);\n\n  PACK_CATALOG.push({ name: \"ai-pack-everything (sharded)\", count: shards.reduce((a,s)=>a+s.count,0), bytes_min: shards.reduce((a,s)=>a+s.approx_bytes,0), files: [\n    \"docs/ai-pack-everything.manifest.min.json\", \"docs/ai-pack-everything.html\"\n  ]});\n}\nwriteEverythingSharded();\n\n// ---------------- Combined \"ALL\" pack (docs + data-config + core + ci) ----------------\n(function(){\n  const names = [\"ai-pack-docs\",\"ai-pack-data-config\",\"ai-pack-core\",\"ai-pack-ci\"];\n  const packs = names.map(name => {\n    const p = JSON.parse(fs.readFileSync(`docs/${name}.min.json`, \"utf8\"));\n    return { name, items: p.items || [] };\n  });\n  const combined = {\n    schema: \"barkday.ai-pack-all.v1\",\n    repo, commit, updated_utc: updatedUtc,\n    sections: Object.fromEntries(packs.map(p => [p.name, { count: p.items.length, items: p.items }]))\n  };\n  const prettyPack = JSON.stringify(combined, null, 2);\n  const minPack    = JSON.stringify(combined);\n\n  fs.writeFileSync(\"docs/ai-pack-all.json\", prettyPack);\n  fs.writeFileSync(\"docs/ai-pack-all.min.json\", minPack);\n  fs.writeFileSync(\"docs/ai-pack-all.txt\",  minPack);\n  console.log(`Wrote docs/ai-pack-all.(json|min.json|txt)`);\n\n  const escapeHtml = s => String(s).replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));\n  const packHtml = `<!doctype html><meta charset=\"utf-8\">\n<title>Barkday • ai-pack-all</title>\n<style>\n  body{font:14px system-ui;margin:24px;max-width:1100px}\n  pre{white-space:pre-wrap;word-break:break-word}\n  code{font-family:ui-monospace,Consolas,monospace}\n  ul{line-height:1.6}\n  .mono{font-family:ui-monospace,Consolas,monospace}\n  .muted{color:#666}\n  .chips a{display:inline-block;margin-right:10px}\n  .warn{background:#fff4ce;padding:8px 10px;border-radius:8px}\n  .ok{background:#e9fff0;padding:8px 10px;border-radius:8px}\n  .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#eee}\n  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:12px;margin:14px 0}\n  .card{border:1px solid #eee;border-radius:10px;padding:12px}\n  .card h3{margin:0 0 6px 0}\n</style>\n<h1>ai-pack-all</h1>\n<p><small>Commit <code>${commit.slice(0,7)}</code> • ${updatedUtc}</small></p>\n\n<div class=\"grid\">\n  <div class=\"card\">\n    <h3>Quick links</h3>\n    <ul>\n      <li><a href=\"ai-docs-list.html\">Docs list (HTML)</a> <span class=\"muted\">• browse & click raw</span></li>\n      <li><a href=\"ai-docs-list.min.json\">Docs list (JSON)</a></li>\n      <li><a href=\"ai-pack-docs.txt\">Docs pack (.txt)</a></li>\n    </ul>\n  </div>\n  <div class=\"card\">\n    <h3>Data/Config</h3>\n    <ul>\n      <li><a href=\"ai-data-config-list.min.json\">data/*.json|*.yaml (list)</a></li>\n      <li><a href=\"ai-pack-data-config.txt\">data-config pack (.txt)</a></li>\n    </ul>\n  </div>\n  <div class=\"card\">\n    <h3>Core & CI</h3>\n    <ul>\n      <li><a href=\"ai-pack-core.txt\">core pack (.txt)</a></li>\n      <li><a href=\"ai-pack-ci.txt\">CI workflows pack (.txt)</a></li>\n    </ul>\n  </div>\n  <div class=\"card\">\n    <h3>Everything (for deep dives)</h3>\n    <ul>\n      <li><a href=\"ai-pack-everything.html\">Everything index (HTML)</a></li>\n      <li><a href=\"ai-pack-everything.manifest.min.json\">Everything manifest (JSON)</a></li>\n    </ul>\n  </div>\n</div>\n\n<p class=\"muted\">Machine-readable combined pack (below):</p>\n<pre id=\"data\">${escapeHtml(prettyPack)}</pre>`;\n  fs.writeFileSync(\"docs/ai-pack-all.html\", packHtml);\n\n  PACK_CATALOG.push({ name: \"ai-pack-all (combined)\", count: names.reduce((a,n)=>a + JSON.parse(fs.readFileSync(`docs/${n}.min.json`,\"utf8\")).items.length, 0), bytes_min: minPack.length, files: [\n    \"docs/ai-pack-all.min.json\", \"docs/ai-pack-all.txt\", \"docs/ai-pack-all.html\"\n  ]});\n})();\n\n// ---------------- tiny catalog of what we emitted ----------------\n(function(){\n  const cat = {\n    schema: \"barkday.ai-pack-catalog.v1\",\n    repo, commit, updated_utc: updatedUtc,\n    packs: PACK_CATALOG\n  };\n  fs.writeFileSync(\"docs/ai-pack-catalog.json\", JSON.stringify(cat, null, 2));\n  fs.writeFileSync(\"docs/ai-pack-catalog.min.json\", JSON.stringify(cat));\n  console.log(\"Wrote docs/ai-pack-catalog.(json|min.json)\");\n})();\n",
      "inline_bytes": 20287,
      "content_sha256": "7748efa7f4c275456f187fc8892e98100695fd502be1c7208d851b7e9b4a8947"
    }
  ]
}